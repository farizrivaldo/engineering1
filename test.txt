 BatchRecord1: async (request, response) => {
    const { area, start, finish } = request.query;
    const queryGet = `
        SELECT 
            data_index AS x, 
            CONVERT(data_format_0 USING utf8) AS BATCH,
            DATE(FROM_UNIXTIME(\`time@timestamp\`) + INTERVAL 4 HOUR) AS label
        FROM 
            \`parammachine_saka\`.\`${area}\`
        WHERE 
            DATE(FROM_UNIXTIME(\`time@timestamp\`)) BETWEEN '${start}' AND '${finish}'
        GROUP BY 
            data_format_0
        ORDER BY
            label;
    `;
    

    try {
      const result = await new Promise((resolve, reject) => {
        db3.query(queryGet, (err, result) => {
          if (err) {
            return reject(err);
          }
          resolve(result);
        });
      });
      return response.status(200).send(result);
    } catch (error) {
      console.error(error);
      return response.status(500).send("Database query failed");
    }
  },

  BatchRecord1_DB2: async (request, response) => {
    const { area, start, finish } = request.query;
    const queryGet = `
        SELECT 
            data_index AS x, 
            CONVERT(data_format_0 USING utf8) AS BATCH,
            DATE(FROM_UNIXTIME(\`time@timestamp\`) + INTERVAL 4 HOUR) AS label
        FROM 
            \`ems_saka\`.\`${area}\`
        WHERE 
            DATE(FROM_UNIXTIME(\`time@timestamp\`)) BETWEEN '${start}' AND '${finish}'
        GROUP BY 
            data_format_0
        ORDER BY
            label;
    `;

    try {
      const result = await new Promise((resolve, reject) => {
        db2.query(queryGet, (err, result) => {
          if (err) {
            return reject(err);
          }
          resolve(result);
        });
      });
      return response.status(200).send(result);
    } catch (error) {
      console.error(error);
      return response.status(500).send("Database query failed");
    }
  },

  BatchRecord3: async (request, response) => {
    const { area, start, finish } = request.query;
    const queryGet = `
        SELECT 
            data_index AS x, 
            CONVERT(data_format_0 USING utf8) AS BATCH,
            DATE(FROM_UNIXTIME(\`time@timestamp\`) + INTERVAL 4 HOUR) AS label
        FROM 
            \`parammachine_saka\`.\`${area}\`
        WHERE 
            DATE(FROM_UNIXTIME(\`time@timestamp\`)) BETWEEN '${start}' AND '${finish}'
        GROUP BY 
            data_format_0
        ORDER BY
            label;
    `;
    db2.query(queryGet, (err, result) => {
      if (err) {
        console.log(err);
        return response.status(500).send("Database query failed");
      }
      return response.status(200).send(result);
    });
  },

  SearchBatchRecord: async (request, response) => {
    const { area, data } = request.query;
    if (!area) {
      return response.status(400).send("Missing required query parameters");
    }

    const getAllColumns = (area) => {
      return new Promise((resolve, reject) => {
        const query = `
        SELECT COLUMN_NAME
        FROM INFORMATION_SCHEMA.COLUMNS
        WHERE TABLE_SCHEMA = 'ems_saka'
        AND TABLE_NAME = ?
        AND COLUMN_NAME NOT IN ('data_format_0', 'data_format_1')
      `;
        db2.query(query, [area], (err, results) => {
          if (err) return reject(err);
          const columns = results.map((result) => result.COLUMN_NAME);
          resolve(columns);
        });
      });
    };

    const getColumnMappings = (area) => {
      return new Promise((resolve, reject) => {
        const query = `
        SELECT data_format_index, comment
        FROM \`${area}_format\`
      `;
        db2.query(query, (err, results) => {
          if (err) return reject(err);
          resolve(results);
        });
      });
    };

    try {
      const columns = await getAllColumns(area);
      const columnMappings = await getColumnMappings(area);

      const mappedColumns = columns.map((col) => {
        const match = col.match(/data_format_(\d+)/);
        if (match) {
          const index = parseInt(match[1], 10);
          const mapping = columnMappings.find(
            (mapping) => mapping.data_format_index === index
          );
          if (mapping) {
            return `\`${col}\` AS \`${mapping.comment}\``;
          }
        }
        return `\`${col}\``;
      });

      const queryGet = `
      SELECT
        ${mappedColumns.join(", ")},
        CONVERT(\`data_format_0\` USING utf8) AS \` BATCH\`,
        CONVERT(\`data_format_1\` USING utf8) AS \`PROCESS\`
      FROM
        \`ems_saka\`.\`${area}\`
      WHERE
        CONVERT(\`data_format_0\` USING utf8) LIKE ?
      ORDER BY
        DATE(FROM_UNIXTIME(\`time@timestamp\`)) ASC;
    `;

      db.query(queryGet, [`%${data}%`], (err, result) => {
        if (err) {
          console.log(err);
          return response.status(500).send("Database query failed");
        }
        return response.status(200).send(result);
      });
    } catch (error) {
      console.log(error);
      return response.status(500).send("Database query failed");
    }
  },



  ChillerGraph: async (request, response) => {
    const { area, start, finish, chiller, komp } = request.query;
    const queryGet = `SELECT
    DATE_FORMAT(FROM_UNIXTIME(\`time@timestamp\`)+ INTERVAL 4 HOUR, '%Y-%m-%d %H:%i') AS label,
    \`time@timestamp\`*1000 AS x,
    data_format_0 AS y
    FROM \`parammachine_saka\`.\`CMT-DB-Chiller-UTY_${area}${komp}${chiller}_data\`
    WHERE
    DATE_FORMAT(FROM_UNIXTIME(\`time@timestamp\`)+ INTERVAL 4 HOUR, '%Y-%m-%d') BETWEEN '${start}' AND '${finish}'
    ORDER BY
    \`time@timestamp\`;`;

    // console.log(queryGet);
    // ada perubahan di bagian from -> si db CHILLER jadi Chiller.
    db3.query(queryGet, (err, result) => {
      return response.status(200).send(result);
    });
  },

ChillerGraph: async (request, response) => {
    const { area, start, finish, chiller, komp } = request.query;
    const queryGet = `
      SELECT
          DATE_FORMAT(FROM_UNIXTIME(\`time@timestamp\`) + INTERVAL 4 HOUR, '%Y-%m-%d %H:%i') AS label,
          \`time@timestamp\` * 1000 AS x,
          data_format_0 AS y
      FROM
          \`test\`.\`CMT-DB-Chiller-UTY_${area}${komp}${chiller}_data\`
      WHERE
          DATE_FORMAT(FROM_UNIXTIME(\`time@timestamp\`) + INTERVAL 4 HOUR, '%Y-%m-%d') BETWEEN '${start}' AND '${finish}'
      UNION ALL
      SELECT
          DATE_FORMAT(FROM_UNIXTIME(\`time@timestamp\`) + INTERVAL 4 HOUR, '%Y-%m-%d %H:%i') AS label,
          \`time@timestamp\` * 1000 AS x,
          data_format_0 AS y
      FROM
          \`parammachine_saka\`.\`CMT-DB-Chiller-UTY2_${area}${komp}${chiller}_data\`
      WHERE
          DATE_FORMAT(FROM_UNIXTIME(\`time@timestamp\`) + INTERVAL 4 HOUR, '%Y-%m-%d') BETWEEN '${start}' AND '${finish}'
      ORDER BY
          x;
    `;
    
    console.log(queryGet);
    db3.query(queryGet, (err, result) => {
      if (err) {
        return response.status(500).send(err);
      }
      return response.status(200).send(result);
    });
  },

  ChillerGraph: async (request, response) => {
    const { area, start, finish, chiller, komp } = request.query;

    const areaFormatted = area.replace(/-/g, '_');

    const queryGet = `
            SELECT
                DATE_FORMAT(FROM_UNIXTIME(\`time@timestamp\`) + INTERVAL 4 HOUR, '%Y-%m-%d %H:%i') AS label,
                \`time@timestamp\` * 1000 AS x,
                data_format_0 AS y
            FROM
                \`newdb\`.\`${areaFormatted}${komp}${chiller}_data\`
            WHERE
                DATE_FORMAT(FROM_UNIXTIME(\`time@timestamp\`) + INTERVAL 4 HOUR, '%Y-%m-%d') BETWEEN '${start}' AND '${finish}'

            UNION ALL

            SELECT
                DATE_FORMAT(FROM_UNIXTIME(\`time@timestamp\`) + INTERVAL 4 HOUR, '%Y-%m-%d %H:%i') AS label,
                \`time@timestamp\` * 1000 AS x,
                data_format_0 AS y
            FROM
                \`parammachine_saka\`.\`CMT-DB-Chiller-UTY2_${area}${komp}${chiller}_data\`
            WHERE
                DATE_FORMAT(FROM_UNIXTIME(\`time@timestamp\`) + INTERVAL 4 HOUR, '%Y-%m-%d') BETWEEN '${start}' AND '${finish}'

            ORDER BY
                x;
        `;
    
    console.log(queryGet);
    db3.query(queryGet, (err, result) => {
      if (err) {
        return response.status(500).send(err);
      }
      return response.status(200).send(result);
    });
  },

  console.log(fetchquery);

  ChillerStatus: async (request, response) => {
    const { start, finish, chiller, komp } = request.query;

    const queryGet = `SELECT
    DATE_FORMAT(FROM_UNIXTIME(a.\`time@timestamp\`)+ INTERVAL 4 HOUR, '%Y-%m-%d %H:%i:%s') AS time,
      case
      when a.data_format_0 = 0 then "OFF"
      when a.data_format_0 = 1 then "ON"
      end AS 'Alarm_Chiller',
      case
      when a1.data_format_0 = 0 then "OFF"
      when a1.data_format_0 = 1 then "ON"
      end as "Status_Chiller",
       case
      when f.data_format_0 = 0 then "OFF"
          when f.data_format_0 = 1 then "ON"
    end as "Fan_Kondensor",
      case
      when d.data_format_0 = 0 then "OFF"
          when d.data_format_0 = 1 then "ON"
    end AS 'Status_Kompresor'
  From
      \`parammachine_saka\`.\`CMT-DB-Chiller-UTY2_R-AlarmCH${chiller}_data\` AS a
  LEFT JOIN
      \`parammachine_saka\`.\`CMT-DB-Chiller-UTY2_R-StatusCH${chiller}_data\` AS a1
    ON
      DATE_FORMAT(FROM_UNIXTIME(a.\`time@timestamp\`), '%Y-%m-%d %H:%i') = DATE_FORMAT(FROM_UNIXTIME(a1.\`time@timestamp\`), '%Y-%m-%d %H:%i')
  LEFT JOIN
      \`parammachine_saka\`.\`CMT-DB-Chiller-UTY2_H-StatFanKondCH${chiller}_data\` AS f
    ON
      DATE_FORMAT(FROM_UNIXTIME(a.\`time@timestamp\`), '%Y-%m-%d %H:%i') = DATE_FORMAT(FROM_UNIXTIME(f.\`time@timestamp\`), '%Y-%m-%d %H:%i')
  LEFT JOIN
      \`parammachine_saka\`.\`CMT-DB-Chiller-UTY2_R-Status${komp}${chiller}_data\` AS d
    ON
      DATE_FORMAT(FROM_UNIXTIME(a.\`time@timestamp\`), '%Y-%m-%d %H:%i') = DATE_FORMAT(FROM_UNIXTIME(d.\`time@timestamp\`), '%Y-%m-%d %H:%i')
  WHERE 
  DATE_FORMAT(FROM_UNIXTIME(a.\`time@timestamp\`)+ INTERVAL 4 HOUR, '%Y-%m-%d') BETWEEN '${start}' AND '${finish}'
      group by a.data_index
      order by DATE_FORMAT(FROM_UNIXTIME(a.\`time@timestamp\`), '%Y-%m-%d %H:%i:%s');`;
    console.log(queryGet);
    db3.query(queryGet, (err, result) => {
      return response.status(200).send(result);
    });
  },


  SearchPMARecord3: async (request, response) => {
    const { data } = request.query;
    const area = "cMT-GEA-L3_EBR_PMA_L3_data"; // Static value

    const getAllColumns = () => {
      return new Promise((resolve, reject) => {
        const query = 
        SELECT COLUMN_NAME
        FROM INFORMATION_SCHEMA.COLUMNS
        WHERE TABLE_SCHEMA = 'parammachine_saka'
        AND TABLE_NAME = ?
        AND COLUMN_NAME NOT IN ('data_format_0', 'data_format_1')
      ;
        db.query(query, [area], (err, results) => {
          if (err) return reject(err);
          const columns = results.map((result) => result.COLUMN_NAME);
          resolve(columns);
        });
      });
    };

    const getColumnMappings = () => {
      return new Promise((resolve, reject) => {
        const query = 
        SELECT data_format_index, comment
        FROM \${area}_format\
      ;
        db.query(query, (err, results) => {
          if (err) return reject(err);
          resolve(results);
        });
      });
    };

    try {
      const columns = await getAllColumns();
      const columnMappings = await getColumnMappings();

      const mappedColumns = columns.map((col) => {
        const match = col.match(/data_format_(\d+)/);
        if (match) {
          const index = parseInt(match[1], 10);
          const mapping = columnMappings.find(
            (mapping) => mapping.data_format_index === index
          );
          if (mapping) {
            return \${col}\ AS \${mapping.comment}\`;
          }
        }
        return \${col}\`;
      });

      const queryGet = 
      SELECT
        ${mappedColumns.join(", ")},
        CONVERT(\data_format_0\ USING utf8) AS \BATCH\,
        CONVERT(\data_format_1\ USING utf8) AS \PROCESS\
      FROM
        \parammachine_saka\.\${area}\
      WHERE
        CONVERT(\data_format_0\ USING utf8) LIKE ?
      ORDER BY
        DATE(FROM_UNIXTIME(\time@timestamp\)) ASC;
    ;
      db.query(queryGet, [%${data}%], (err, result) => {
        if (err) {
          console.log(err);
          return response.status(500).send("Database query failed");
        }
        return response.status(200).send(result);
      });
    } catch (error) {
      console.log(error);
      return response.status(500).send("Database query failed");
    }
  },